<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Monad Checker Intelligence — Testnet</title>
<meta name="description" content="Monad address intelligence — balance, txs, volume, gas, day-streak and D3 network graph. Chain ID 10143."/>
<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<style>
:root{
  --bg:#070812; --muted:#9fb0ff; --text:#eaf0ff;
  --accent1:#6ee7ff; --accent2:#a78bfa; --ok:#10d7a3; --danger:#ff6b6b;
  --panel:#0b1220cc; --card-border:#10162b;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
canvas#bg{position:fixed;inset:0;z-index:-2}
.container{max-width:1180px;margin:28px auto;padding:0 16px 80px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#021128}
.h1{font-size:20px;font-weight:700}
.controls{display:flex;gap:10px;align-items:center}
.card{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));border:1px solid var(--card-border);border-radius:14px;padding:14px;box-shadow:0 10px 30px #0008;backdrop-filter:blur(6px)}
.toolbar{display:flex;gap:10px;align-items:center}
.input{flex:1;min-width:220px;background:#0d1526;border:1px solid #232b49;padding:12px 14px;border-radius:12px;color:var(--text)}
.btn{padding:10px 14px;border-radius:12px;border:none;cursor:pointer;font-weight:700}
.btn.primary{background:linear-gradient(135deg,var(--accent1),var(--accent2));color:#021128}
.btn.ghost{background:transparent;border:1px solid #243052;color:var(--text)}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
.stat{padding:12px;border-radius:10px;border:1px solid #17203a;background:linear-gradient(180deg, rgba(255,255,255,.01), transparent)}
.stat .label{font-size:12px;color:var(--muted)}
.stat .value{font-size:18px;font-weight:700;margin-top:6px}
.small{font-size:12px;color:var(--muted)}
.row{display:flex;gap:10px;align-items:center}
.progress{height:8px;background:#0b1324;border-radius:999px;overflow:hidden;border:1px solid #18263f;margin-top:8px}
.progress > b{display:block;height:100%;background:linear-gradient(90deg,var(--accent1),var(--accent2));width:0%}
.panel-wide{margin-top:18px;padding:12px;border-radius:12px;border:1px solid #17203a}
.legend{display:flex;gap:8px;align-items:center;margin-top:8px}
.legend .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
.dot.in{background:var(--ok)}.dot.out{background:var(--danger)}.dot.self{background:#93c5fd}
.footer{opacity:.8;margin-top:18px;font-size:13px}
.code{font-family:ui-monospace,monospace;font-size:12px;color:#cfe6ff}
#graph{width:100%;height:520px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,.005));border:1px solid #12203a;overflow:hidden}
.note{font-size:12px;color:var(--muted);margin-top:8px}
.warning{color:#ffd166;font-weight:700}
@media(max-width:880px){.grid-3{grid-template-columns:1fr}}
.mono{font-family:ui-monospace,monospace}
.topbar-actions{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<canvas id="bg"></canvas>

<div class="container">
  <div class="header">
    <div class="brand">
      <div class="logo">M</div>
      <div>
        <div class="h1">Monad Checker Intelligence</div>
        <div class="small">Chain ID: <span class="code">10143</span> · Manual RPC: <span class="code">https://rpc.ankr.com/monad_testnet</span></div>
      </div>
    </div>
    <div class="controls topbar-actions">
      <button id="connectBtn" class="btn ghost">Connect Wallet</button>
      <div class="small">Credit: <a href="https://x.com/ega_2ez4crypto" target="_blank" style="color:var(--accent1)">@ega_2ez4crypto</a></div>
    </div>
  </div>

  <div class="card">
    <div class="toolbar">
      <input id="addr" class="input mono" placeholder="Paste MONAD testnet address (0x...) or leave blank to use connected wallet" />
      <button id="scanBtn" class="btn primary">Scan</button>
      <button id="exportBtn" class="btn ghost">Export JSON</button>
    </div>

    <div style="display:flex;gap:12px;align-items:center;margin-top:10px;flex-wrap:wrap">
      <label class="row small"><input type="checkbox" id="genesis" /> Full History (Genesis) — <span class="warning">&nbsp;heavy</span></label>
      <label class="row small">Blocks chunk <input id="chunk" type="number" value="250" style="width:90px;margin-left:6px" /></label>
      <label class="row small">Logs chunk <input id="logchunk" type="number" value="8000" style="width:90px;margin-left:6px" /></label>
      <div style="margin-left:auto" class="small">Mode: <span id="modeLabel">Manual RPC (Ankr)</span></div>
    </div>

    <div class="grid-3">
      <div class="stat">
        <div class="label">Balance</div>
        <div id="balance" class="value mono">— MON</div>
        <div class="small" id="nonceLine">Tx Count (nonce): —</div>
      </div>
      <div class="stat">
        <div class="label">Total Volume (In / Out)</div>
        <div id="volume" class="value mono">— / — MON</div>
        <div class="small">Sum of native transfers (approx)</div>
      </div>
      <div class="stat">
        <div class="label">Gas Spent (approx)</div>
        <div id="gas" class="value mono">— MON</div>
        <div class="small">Gas * price across scanned tx (approx)</div>
      </div>
    </div>

    <div class="grid-3" style="margin-top:10px">
      <div class="stat">
        <div class="label">Active Days</div>
        <div id="activeDays" class="value mono">—</div>
        <div class="small">Unique calendar days with txs</div>
      </div>
      <div class="stat">
        <div class="label">Current Day Streak</div>
        <div id="streak" class="value mono">—</div>
        <div class="small">Longest consecutive day streak</div>
      </div>
      <div class="stat">
        <div class="label">First Seen / Last Seen</div>
        <div id="seen" class="value mono">—</div>
        <div class="small">Timestamps from scanned history</div>
      </div>
    </div>

    <div>
      <div class="label" style="margin-top:12px">Scan Progress</div>
      <div class="progress"><b id="prog"></b></div>
    </div>
  </div>

  <div class="panel-wide card" style="margin-top:18px">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <div style="font-weight:700">Activity Timeline</div>
      <div class="small">Daily txs & native volume</div>
    </div>
    <canvas id="timeline" height="220" style="margin-top:12px"></canvas>
  </div>

  <div class="panel-wide card" style="margin-top:14px">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <div style="font-weight:700">Counterparty Graph</div>
      <div class="small">Immediate counterparties (aggregated)</div>
    </div>
    <div id="graph" style="margin-top:12px"></div>
    <div class="legend">
      <div><span class="dot self"></span> Target</div>
      <div><span class="dot in"></span> Inflow</div>
      <div><span class="dot out"></span> Outflow</div>
    </div>
  </div>

  <div class="footer">
    Monad Checker Intelligence · Chain ID 10143 · Credit: <a href="https://x.com/ega_2ez4crypto" target="_blank">@ega_2ez4crypto</a>
  </div>
</div>

<script>
/* ---------------- Animated background ---------------- */
(() => {
  const c = document.getElementById('bg'), ctx = c.getContext('2d');
  let w = innerWidth, h = innerHeight; c.width = w; c.height = h;
  addEventListener('resize', () => { w = innerWidth; h = innerHeight; c.width = w; c.height = h;});
  const orbs = Array.from({length:110}, () => ({x:Math.random()*w, y:Math.random()*h, vx:(Math.random()-0.5)*0.35, vy:(Math.random()-0.5)*0.35, r: Math.random()*1.8+0.6}));
  function frame() {
    ctx.clearRect(0,0,w,h);
    const cx = w*0.6, cy = h*0.4;
    const g = ctx.createRadialGradient(cx,cy,0,cx,cy,700); g.addColorStop(0, 'rgba(23,28,58,.35)'); g.addColorStop(1, 'transparent');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    orbs.forEach(o=>{
      o.x += o.vx; o.y += o.vy; if(o.x<0||o.x>w) o.vx *= -1; if(o.y<0||o.y>h) o.vy *= -1;
      ctx.beginPath(); ctx.fillStyle = 'rgba(160,190,255,0.45)'; ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill();
    });
    requestAnimationFrame(frame);
  }
  frame();
})();

/* ---------------- Setup providers ---------------- */
const CHAIN_ID = 10143;
const CHAIN_ID_HEX = '0x279f'; // 10143
const ANKR_RPC = "https://rpc.ankr.com/monad_testnet";
const ALTERNATE_RPC = "https://testnet-rpc.monad.xyz"; // optional
let manualProvider = new ethers.JsonRpcProvider(ANKR_RPC, {chainId: CHAIN_ID, name: "monad-testnet"});
let walletProvider = null; // ethers provider from injected wallet (if connected)
let useProvider = manualProvider; // current provider used

/* ---------------- UI refs ---------------- */
const ui = {
  addr: document.getElementById('addr'),
  scan: document.getElementById('scanBtn'),
  export: document.getElementById('exportBtn'),
  connect: document.getElementById('connectBtn'),
  genesis: document.getElementById('genesis'),
  chunk: document.getElementById('chunk'),
  logchunk: document.getElementById('logchunk'),
  prog: document.getElementById('prog'),
  balance: document.getElementById('balance'),
  nonceLine: document.getElementById('nonceLine'),
  volume: document.getElementById('volume'),
  gas: document.getElementById('gas'),
  activeDays: document.getElementById('activeDays'),
  streak: document.getElementById('streak'),
  seen: document.getElementById('seen'),
  modeLabel: document.getElementById('modeLabel'),
};
let timelineChart = null;

/* helpers */
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const hexToBig = h => { try { return BigInt(h); } catch(e){ return 0n; } };

/* ---------------- Wallet connect & chain add/switch ---------------- */
async function trySwitchOrAddChain() {
  if(!window.ethereum) throw new Error('No injected wallet found.');
  try {
    // try switch
    await window.ethereum.request({ method: 'wallet_switchEthereumChain', params:[{ chainId: CHAIN_ID_HEX }] });
    return true;
  } catch(switchErr) {
    // 4902 = chain not added
    if(switchErr && (switchErr.code === 4902 || /Unrecognized chain/.test(switchErr.message||''))) {
      try {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: CHAIN_ID_HEX,
            chainName: 'Monad Testnet',
            nativeCurrency: { name: 'MON', symbol: 'MON', decimals: 18 },
            rpcUrls: [ANKR_RPC, ALTERNATE_RPC],
            blockExplorerUrls: ['https://testnet.monadexplorer.com']
          }]
        });
        // after add, try switch again (some wallets auto-switch)
        try { await window.ethereum.request({ method: 'wallet_switchEthereumChain', params:[{ chainId: CHAIN_ID_HEX }] }); } catch(_) {}
        return true;
      } catch(addErr) {
        console.warn('Add chain failed', addErr);
        throw addErr;
      }
    }
    throw switchErr;
  }
}

async function connectWallet(){
  if(!window.ethereum){ alert('No injected wallet found (MetaMask). Install MetaMask and try again.'); return; }
  try {
    await trySwitchOrAddChain(); // ensure chain present
    await window.ethereum.request({ method: 'eth_requestAccounts' });
    walletProvider = new ethers.BrowserProvider(window.ethereum, "any");
    useProvider = walletProvider;
    ui.modeLabel.textContent = 'Connected Wallet (provider)';
    ui.connect.textContent = 'Wallet Connected';
    ui.connect.classList.remove('ghost'); ui.connect.classList.add('primary');
    // prefill address
    const accounts = await walletProvider.listAccounts();
    if(accounts && accounts.length) ui.addr.value = accounts[0].address || accounts[0];
    console.info('Wallet connected, provider ready');
  } catch(err) {
    console.error('connectWallet failed', err);
    alert('Wallet connect failed: ' + (err.message || err));
  }
}
ui.connect.addEventListener('click', connectWallet);

/* ---------------- Provider wrappers ---------------- */
async function rpc_getBlockNumber(){ return await useProvider.getBlockNumber(); }
async function rpc_getBalance(addr){ return await useProvider.getBalance(addr); }
async function rpc_getTransactionCount(addr){ return await useProvider.getTransactionCount(addr); }
async function rpc_getBlockWithTxs(num){ return await useProvider.getBlockWithTransactions(num); }
async function rpc_getBlock(num){ return await useProvider.getBlock(num); }
async function rpc_getCode(addr){ return await useProvider.getCode(addr); }
async function rpc_getLogs(from, to, topics){
  try { return await useProvider.getLogs({ fromBlock: from, toBlock: to, topics }); }
  catch(e){ console.warn('getLogs failed', e.message); return []; }
}

/* ---------------- Core scanner (chunked) ---------------- */
async function scanAddressFlow(inputAddress){
  const target = (inputAddress || ui.addr.value || '').trim();
  if(!ethers.isAddress(target)){ alert('Please paste a valid 0x address or connect wallet.'); return; }
  ui.prog.style.width = '0%';
  // choose provider (if wallet connected and input empty, use wallet provider)
  if(walletProvider && (!inputAddress && ui.addr.value.trim()==='')) { useProvider = walletProvider; ui.modeLabel.textContent='Connected Wallet (provider)'; }
  else { useProvider = manualProvider; ui.modeLabel.textContent='Manual RPC (Ankr)'; }

  // fetch basic
  let balance, nonce, head;
  try {
    [balance, nonce, head] = await Promise.all([ rpc_getBalance(target), rpc_getTransactionCount(target), rpc_getBlockNumber() ]);
  } catch(e) {
    console.error('basic RPC failed', e);
    alert('RPC error: ' + (e.message || e));
    return;
  }
  ui.balance.textContent = `${Number(ethers.formatEther(balance)).toFixed(6)} MON`;
  ui.nonceLine.textContent = `Tx Count (nonce): ${nonce}`;

  const state = { peers:{}, days:{}, inflow:0n, outflow:0n, gasSpent:0n, totalNativeTxs:0, firstSeen: Infinity, lastSeen:0 };

  const genesis = ui.genesis.checked;
  const CHUNK = Math.max(50, Number(ui.chunk.value) || 250);
  const LOG_CHUNK = Math.max(2000, Number(ui.logchunk.value) || 8000);

  const startBlock = genesis ? 0 : Math.max(0, Number(head) - CHUNK * 12);
  const endBlock = Number(head);
  const totalBlocks = endBlock - startBlock + 1;
  let scannedBlocks = 0;

  // block scanning (native txs)
  for(let from=startBlock; from<=endBlock; from += CHUNK){
    const to = Math.min(endBlock, from + CHUNK -1);
    // small parallelism groups
    const PAR = 6;
    for(let b=from; b<=to; b+=PAR){
      const arr=[]; for(let i=0;i<PAR && b+i<=to;i++) arr.push(b+i);
      const blks = await Promise.all(arr.map(n => rpc_getBlockWithTxs(n).catch(()=>null)));
      for(const blk of blks){
        scannedBlocks++;
        if(!blk) continue;
        const ts = Number(blk.timestamp || 0);
        const dkey = new Date(ts*1000).toISOString().slice(0,10);
        for(const tx of (blk.transactions || [])){
          const fromAddr = (tx.from||'').toLowerCase();
          const toAddr = (tx.to||'').toLowerCase();
          const targetLower = target.toLowerCase();
          if(fromAddr === targetLower || toAddr === targetLower){
            const isOut = fromAddr === targetLower;
            const other = ethers.getAddress(isOut ? (tx.to||'0x0000000000000000000000000000000000000000') : tx.from);
            const value = hexToBig(tx.value || '0x0');
            state.days[dkey] ??= {in:0,out:0,count:0};
            if(isOut){ state.outflow += value; state.days[dkey].out += Number(ethers.formatEther(value)); }
            else { state.inflow += value; state.days[dkey].in += Number(ethers.formatEther(value)); }
            state.days[dkey].count++;
            state.peers[other] ??= {in:0n,out:0n,inTx:0,outTx:0,isContract:false};
            if(isOut){ state.peers[other].out += value; state.peers[other].outTx++; }
            else { state.peers[other].in += value; state.peers[other].inTx++; }
            if(tx.gasPrice){ try{ state.gasSpent += (hexToBig(tx.gasPrice) * hexToBig(tx.gas || tx.gasLimit || '0x0')); }catch(_){} }
            state.totalNativeTxs++;
            state.firstSeen = Math.min(state.firstSeen, ts);
            state.lastSeen = Math.max(state.lastSeen, ts);
          }
        }
      }
      // progress
      ui.prog.style.width = Math.min(65, (scannedBlocks / Math.max(1, totalBlocks)) * 65).toFixed(1) + '%';
      await sleep(8);
    }
  }

  // logs scanning (Transfer topics) aggregated
  const TRANSFER_TOPIC = ethers.id("Transfer(address,address,uint256)");
  for(let from=0; from<=endBlock; from += LOG_CHUNK){
    const to = Math.min(endBlock, from + LOG_CHUNK - 1);
    try{
      const logs = await rpc_getLogs(from, to, [TRANSFER_TOPIC]);
      for(const L of logs){
        const f = "0x" + (L.topics?.[1]||'').slice(26);
        const t = "0x" + (L.topics?.[2]||'').slice(26);
        if(!f || !t) continue;
        if(f.toLowerCase() !== target.toLowerCase() && t.toLowerCase() !== target.toLowerCase()) continue;
        const out = f.toLowerCase() === target.toLowerCase();
        const other = ethers.getAddress(out ? t : f);
        // get block timestamp
        const blk = await rpc_getBlock(Number(L.blockNumber));
        const ts = Number(blk?.timestamp || 0);
        const dk = new Date(ts*1000).toISOString().slice(0,10);
        state.days[dk] ??= {in:0,out:0,count:0};
        state.days[dk].count++;
        state.peers[other] ??= {in:0n,out:0n,inTx:0,outTx:0,isContract:false};
      }
    }catch(e){ console.warn('logs chunk failed', e.message||e); }
    ui.prog.style.width = (70 + Math.min(25, ((to / Math.max(1,endBlock)) * 25))).toFixed(1) + '%';
    await sleep(12);
  }

  // label peers (contract or EOA)
  await Promise.all(Object.keys(state.peers).map(async p => {
    try{ const code = await rpc_getCode(p); state.peers[p].isContract = (code && code !== '0x'); }catch(_){}
  }));

  // compute outputs & UI
  const totalIn = Number(ethers.formatEther(state.inflow));
  const totalOut = Number(ethers.formatEther(state.outflow));
  const gasEth = Number(ethers.formatEther(state.gasSpent || 0n));
  ui.volume.textContent = `${totalIn.toFixed(5)} / ${totalOut.toFixed(5)} MON`;
  ui.gas.textContent = `${gasEth.toFixed(6)} MON`;
  ui.activeDays.textContent = Object.keys(state.days).length;
  ui.seen.textContent = `${new Date((state.firstSeen===Infinity?Date.now()/1000:state.firstSeen)*1000).toLocaleString()} — ${new Date(state.lastSeen*1000).toLocaleString()}`;
  // streak
  const dayKeys = Object.keys(state.days).sort();
  let longest = 0, current = 0, prev = null;
  for(const d of dayKeys){
    const t = new Date(d + 'T00:00:00Z').valueOf();
    if(prev === null || t - prev > 86400000) current = 1; else current++;
    longest = Math.max(longest, current);
    prev = t;
  }
  ui.streak.textContent = longest;

  // visuals
  renderTimeline(state.days);
  renderGraph(target, state);
  ui.prog.style.width = '100%';

  // store last report
  window.lastReport = { address: target, balance: Number(ethers.formatEther(balance)), nonce, headBlock: endBlock, stats: state, generatedAt: new Date().toISOString(), provider: (useProvider.connection?.url || 'wallet-provider') };
}

/* ---------------- Timeline (Chart.js) ---------------- */
function renderTimeline(daysObj){
  const labels = Object.keys(daysObj).sort();
  const txCounts = labels.map(k => daysObj[k].count || 0);
  const inflows = labels.map(k => daysObj[k].in || 0);
  if(timelineChart) timelineChart.destroy();
  const ctx = document.getElementById('timeline').getContext('2d');
  timelineChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'Tx Count', data: txCounts, backgroundColor: 'rgba(100,150,255,0.5)', stack: 'a' },
        { label: 'Native Volume (MON)', data: inflows, type: 'line', yAxisID: 'vol', tension:0.25, borderColor: '#6ee7ff', pointRadius:2 }
      ]
    },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      scales: {
        x: { ticks: { color: '#bcd6ff' } },
        y: { beginAtZero: true, ticks: { color: '#bcd6ff' } },
        vol: { position: 'right', beginAtZero: true, grid: { display:false }, ticks: { color: '#bcd6ff' } }
      },
      plugins: { legend: { labels: { color: '#dfefff' } } }
    }
  });
}

/* ---------------- Graph (D3) ---------------- */
function renderGraph(centerAddr, state){
  const el = document.getElementById('graph'); el.innerHTML = '';
  const width = el.clientWidth || 1000, height = 520;
  const svg = d3.select(el).append('svg').attr('width', width).attr('height', height);
  const nodesMap = new Map();
  nodesMap.set(centerAddr.toLowerCase(), { id:centerAddr.toLowerCase(), label:centerAddr, type:'self' });
  const peers = Object.entries(state.peers || {}).map(([addr,info])=>({addr,score:(info.inTx||0)+(info.outTx||0),info}))
    .sort((a,b)=>b.score-a.score).slice(0,140);
  peers.forEach(p=> nodesMap.set(p.addr.toLowerCase(), { id:p.addr.toLowerCase(), label:p.addr, type: p.info.isContract ? 'contract' : 'peer' }));
  const nodes = Array.from(nodesMap.values());
  const links = [];
  for(const n of nodes){
    if(n.id === centerAddr.toLowerCase()) continue;
    const info = state.peers[n.id] || {in:0,out:0};
    const val = (Number(info.in?ethers.formatEther(info.in):0) + Number(info.out?ethers.formatEther(info.out):0));
    links.push({ source: n.id, target: centerAddr.toLowerCase(), value: val || 1 });
  }

  const g = svg.append('g');
  svg.call(d3.zoom().scaleExtent([0.4,4]).on('zoom', (e)=> g.attr('transform', e.transform)));

  const link = g.append('g').selectAll('line').data(links).enter().append('line')
    .attr('stroke', '#23d1a2').attr('stroke-opacity', 0.45).attr('stroke-width', d => Math.min(6, 1 + Math.log((d.value||1)+2)));
  const node = g.append('g').selectAll('circle').data(nodes).enter().append('circle')
    .attr('r', d => d.type === 'self' ? 10 : 5.5)
    .attr('fill', d => d.type === 'self' ? '#93c5fd' : (d.type === 'contract' ? '#f59e0b' : '#a3b8ff'))
    .attr('stroke', '#18263f').attr('stroke-width', 1.2)
    .style('cursor','pointer');
  const label = g.append('g').selectAll('text').data(nodes).enter().append('text')
    .text(d => d.type==='self' ? 'TARGET' : (d.label.slice(0,6) + '…' + d.label.slice(-4)))
    .attr('font-size', 10).attr('fill', '#cfe6ff').attr('dx', 8).attr('dy', 4);
  const tooltip = d3.select('body').append('div').style('position','fixed').style('pointer-events','none')
    .style('background','#081026cc').style('border','1px solid #21304f').style('padding','8px').style('border-radius','8px').style('color','#dfefff').style('display','none');

  node.on('mouseover', (e,d) => { tooltip.style('display','block').html(`<div class="mono">${short(d.id)}</div><div style="font-size:12px;color:#bcd6ff">${d.type}</div>`); })
    .on('mousemove', (e)=> tooltip.style('left',(e.clientX+12)+'px').style('top',(e.clientY+12)+'px'))
    .on('mouseout', ()=> tooltip.style('display','none'))
    .on('click', (e,d) => { ui.addr.value = d.id; });

  const sim = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d=>d.id).distance(d => 80 + Math.min(140, Math.log((d.value||1)+2)*18)).strength(0.85))
    .force('charge', d3.forceManyBody().strength(-220))
    .force('center', d3.forceCenter(width/2, height/2))
    .alpha(0.95).alphaDecay(0.03)
    .on('tick', ()=> {
      link.attr('x1',d=>d.source.x).attr('y1',d=>d.source.y).attr('x2',d=>d.target.x).attr('y2',d=>d.target.y);
      node.attr('cx',d=>d.x).attr('cy',d=>d.y);
      label.attr('x',d=>d.x).attr('y',d=>d.y);
    });

  function short(a){ return a.slice(0,6) + '…' + a.slice(-4); }
}

/* ---------------- Export JSON ---------------- */
ui.export.addEventListener('click', () => {
  if(!window.lastReport){ alert('Run scan first'); return; }
  const blob = new Blob([JSON.stringify(window.lastReport, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `monad-report-${window.lastReport.address}.json`; a.click(); URL.revokeObjectURL(url);
});

/* ---------------- Scan button wiring ---------------- */
ui.scan.addEventListener('click', async () => {
  const input = ui.addr.value.trim();
  // if wallet is connected and input empty, use wallet provider
  if(walletProvider && !input) { useProvider = walletProvider; ui.modeLabel.textContent='Connected Wallet (provider)'; }
  else { useProvider = manualProvider; ui.modeLabel.textContent='Manual RPC (Ankr)'; }
  try{
    ui.prog.style.width = '2%';
    await scanAddressFlow(input);
  }catch(err){
    console.error(err);
    alert('Scan failed: ' + (err.message || err));
    ui.prog.style.width = '0%';
  }
});

/* small util */
function short(a){ return a.slice(0,6) + '…' + a.slice(-4); }
</script>
</body>
</html>
