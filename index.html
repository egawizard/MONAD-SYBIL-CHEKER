<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sybil Checker — MONAD Testnet (Genesis Mode)</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
/* ——— UI & background sama seperti sebelumnya (diringkas) ——— */
:root{--bg:#080a12;--card:#0e1220cc;--text:#e8ecff;--muted:#a6b0d9;--ok:#10d7a3;--danger:#ff6b6b}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui}
canvas#bg{position:fixed;inset:0;z-index:-1;background:radial-gradient(1200px 800px at 70% 20%,#0a1028 0%,#080a12 60%,#05070f 100%)}
.wrap{max-width:1180px;margin:24px auto;padding:0 16px 80px}
.card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));border:1px solid #1b2442;border-radius:18px;padding:16px;box-shadow:0 10px 30px #0008, inset 0 1px 0 #ffffff10;backdrop-filter:blur(8px)}
.title{font-weight:700;letter-spacing:.3px;font-size:26px;margin:6px 0 12px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
input,button{border-radius:12px;padding:12px 14px;border:1px solid #29345f;background:#0e1430;color:#e8ecff}
button{background:linear-gradient(135deg,#22d3ee,#a78bfa);border:none;color:#041018;font-weight:700;cursor:pointer}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
.stat{border:1px solid #1a2246;padding:14px;border-radius:14px;background:rgba(15,20,40,.5)}
.label{font-size:12px;color:var(--muted)}
.value{font-size:20px;font-weight:700;margin-top:6px}
.risk.low{color:var(--ok)}.risk.med{color:#ffd166}.risk.high{color:var(--danger)}
.progress{height:8px;background:#0e1430;border:1px solid #27325d;border-radius:999px;overflow:hidden}
.progress>b{display:block;height:100%;background:linear-gradient(90deg,#22d3ee,#a78bfa)}
.legend{display:flex;gap:10px;align-items:center}
.dot{width:10px;height:10px;border-radius:50%;display:inline-block}
.self{background:#93c5fd}.in{background:#23d1a2}.out{background:#ff6b6b}.contract{background:#f59e0b}
#graph{width:100%;height:640px;border-radius:18px;border:1px solid #1b2442;background:linear-gradient(180deg,rgba(10,14,32,.7),rgba(10,14,32,.4))}
.notice{font-size:12px;color:#9fb0ff}
</style>
</head>
<body>
<canvas id="bg"></canvas>
<div class="wrap">
  <div class="card">
    <div class="title">Sybil Checker — MONAD Testnet</div>
    <div class="row">
      <input id="addr" placeholder="Paste a MONAD testnet address (0x…)" class="mono" style="flex:1" />
      <button id="scanBtn">Scan</button>
      <button id="exportBtn">Export</button>
    </div>
    <div class="row" style="margin-top:8px">
      <label class="row" style="gap:6px">
        <input id="genesisMode" type="checkbox" />
        <span>Scan from genesis (cache & resume)</span>
      </label>
      <label class="row" style="gap:6px">
        Chunk (blocks): <input id="chunk" type="number" min="100" value="300" style="width:100px">
      </label>
      <label class="row" style="gap:6px">
        Parallel: <input id="par" type="number" min="1" max="12" value="8" style="width:80px">
      </label>
      <label class="row" style="gap:6px">
        Logs chunk: <input id="logChunk" type="number" min="1000" value="8000" style="width:100px">
      </label>
    </div>

    <div class="grid-3" style="margin-top:12px">
      <div class="stat"><div class="label">Balance</div><div id="balance" class="value mono">—</div></div>
      <div class="stat"><div class="label">Tx Count (nonce)</div><div id="nonce" class="value mono">—</div></div>
      <div class="stat"><div class="label">Sybil Risk</div><div id="risk" class="value risk low">—</div></div>
    </div>
    <div class="grid-3" style="margin-top:8px">
      <div class="stat"><div class="label">Unique Counterparties</div><div id="peers" class="value mono">—</div></div>
      <div class="stat"><div class="label">Inflow / Outflow (native)</div><div id="flow" class="value mono">—</div></div>
      <div class="stat"><div class="label">First Seen / Last Seen</div><div id="seen" class="value mono">—</div></div>
    </div>
    <div style="margin-top:10px">
      <div class="label">Progress</div><div class="progress"><b id="prog" style="width:0%"></b></div>
      <div class="notice">Genesis Mode will cache and resume automatically. Graph uses aggregated edges for full-history performance.</div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <div class="title">Activity Timeline</div>
    <canvas id="timeline" height="260"></canvas>
  </div>

  <div class="card" style="margin-top:16px">
    <div class="title">Network Graph</div>
    <div class="legend" style="margin-bottom:8px">
      <span class="dot self"></span><span class="notice">Target</span>
      <span class="dot in"></span><span class="notice">Inflow</span>
      <span class="dot out"></span><span class="notice">Outflow</span>
      <span class="dot contract"></span><span class="notice">Contract</span>
    </div>
    <div id="graph"></div>
  </div>

  <div class="notice" style="margin-top:8px">
    Credits: created by <a href="https://x.com/ega_2ez4crypto" target="_blank">@ega_2ez4crypto</a> · RPC: https://testnet-rpc.monad.xyz · Chain ID: 10143
  </div>
</div>

<script>
/* Background animation (ringkas) */
(()=>{const c=document.getElementById('bg'),x=c.getContext('2d');let w=innerWidth,h=innerHeight;c.width=w;c.height=h;addEventListener('resize',()=>{w=innerWidth;h=innerHeight;c.width=w;c.height=h});const P=Array.from({length:120},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-.5)*.4,vy:(Math.random()-.5)*.4,r:Math.random()*2+0.6}));(function d(){x.clearRect(0,0,w,h);P.forEach(p=>{p.x+=p.vx;p.y+=p.vy;if(p.x<0||p.x>w)p.vx*=-1;if(p.y<0||p.y>h)p.vy*=-1;x.fillStyle='rgba(173,199,255,.55)';x.beginPath();x.arc(p.x,p.y,p.r,0,6.283);x.fill()});requestAnimationFrame(d)})()})();

/* RPC */
const RPC_URL="https://testnet-rpc.monad.xyz";
const provider=new ethers.JsonRpcProvider(RPC_URL,{chainId:10143,name:"monad-testnet"});

/* IndexedDB minimal wrapper */
const DB_NAME='monad-sybil-db'; const STORE='scans';
function idb(){return new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE,{keyPath:'key'});r.onerror=()=>rej(r.error);r.onsuccess=()=>res(r.result)});}
async function dbGet(key){const db=await idb();return new Promise((res,rej)=>{const tx=db.transaction(STORE).objectStore(STORE).get(key);tx.onsuccess=()=>res(tx.result?.value||null);tx.onerror=()=>rej(tx.error)})}
async function dbPut(key,value){const db=await idb();return new Promise((res,rej)=>{const tx=db.transaction(STORE,'readwrite').objectStore(STORE).put({key,value});tx.oncomplete=()=>res();tx.onerror=()=>rej(tx.error)})}

/* UI refs */
const ui={addr:addr,scan:scanBtn,export:exportBtn,prog:prog,balance:balance,nonce:nonce,risk:risk,peers:peers,flow:flow,seen:seen,genesis:genesisMode,chunk:chunk,par:par,logChunk:logChunk};
const fmtEth=(wei)=>ethers.formatEther(wei); const short=a=>a.slice(0,6)+'…'+a.slice(-4); const dayKey=ts=>new Date(ts*1000).toISOString().slice(0,10);
let timelineChart=null,lastReport=null;

/* Sybil score heuristic (sama) */
function sybilScore(s){let score=0;const ageDays=(Date.now()/1000-s.firstSeen)/86400, small=s.smallTxs/(s.totalNativeTxs||1), peers=Object.keys(s.peers).length, outRatio=s.outCount/(s.inCount+1); if(ageDays<7)score+=20; if(peers>25&&small>0.7)score+=30; if(outRatio>2)score+=20; if(s.twoWayPairs>6)score+=15; if(s.bursts>2)score+=15; let label='Low',cls='low'; if(score>=65){label='High';cls='high'} else if(score>=35){label='Medium';cls='med'} return{score,label,cls};}

/* Helpers */
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

/* ----- Core: scanner with Genesis Mode + cache ----- */
async function scan(addr){
  if(!ethers.isAddress(addr)) throw new Error("Invalid address.");
  ui.prog.style.width='0%';

  const [bal,nonce,head]=await Promise.all([provider.getBalance(addr),provider.getTransactionCount(addr),provider.getBlockNumber()]);
  ui.balance.textContent=`${Number(fmtEth(bal)).toFixed(6)} MON`;
  ui.nonce.textContent=String(nonce);

  // Load cache or init
  const cacheKey=`${addr.toLowerCase()}`;
  let state= await dbGet(cacheKey) || {
    headAtStart: head,
    lastScannedBlock:-1,
    peers:{}, // {addr:{in:bigint,out:bigint,inTx:0,outTx:0,isContract:false}}
    edges:{}, // "a->b":{value,count,native}
    days:{},  // "YYYY-MM-DD":{in,out,ev}
    inflow:0n,outflow:0n,inCount:0,outCount:0,smallTxs:0,totalNativeTxs:0,firstSeen:Infinity,lastSeen:0,
  };

  const startBlock = ui.genesis.checked ? (state.lastScannedBlock+1) : Math.max(0, head - Number(ui.chunk.value)*10);
  const endBlock = head;
  const totalSpan = endBlock - (ui.genesis.checked ? 0 : startBlock) + 1;

  // Native transfers: scan blocks in chunks and parallel
  const CHUNK = Math.max(50, Number(ui.chunk.value));
  const PAR = Math.min(12, Math.max(1, Number(ui.par.value)));
  for(let from=startBlock; from<=endBlock; from+=CHUNK){
    const to = Math.min(endBlock, from+CHUNK-1);
    const batches=[]; for(let b=from; b<=to; b+=PAR){ const arr=[]; for(let i=0;i<PAR&&b+i<=to;i++) arr.push(b+i); batches.push(arr); }
    for(const arr of batches){
      const blks = await Promise.all(arr.map(n=>provider.getBlockWithTransactions(n)));
      blks.forEach(blk=>{
        blk.transactions.forEach(tx=>{
          const lowerFrom = tx.from?.toLowerCase(); const lowerTo = tx.to?.toLowerCase();
          if(lowerFrom===addr.toLowerCase() || lowerTo===addr.toLowerCase()){
            const isOut = lowerFrom===addr.toLowerCase();
            const other = ethers.getAddress((isOut? tx.to : tx.from) || "0x0000000000000000000000000000000000000000");
            const value = BigInt(tx.value?.toString()||"0"); const ts=blk.timestamp;
            state.days[dayKey(ts)] ??= {in:0,out:0,ev:0};
            if(isOut){ state.outflow+=value; state.outCount++; state.days[dayKey(ts)].out += Number(fmtEth(value)); }
            else     { state.inflow+=value;  state.inCount++;  state.days[dayKey(ts)].in  += Number(fmtEth(value)); }
            if(Number(fmtEth(value))<0.02) state.smallTxs++;
            state.peers[other] ??= {in:0n,out:0n,inTx:0,outTx:0,isContract:false};
            if(isOut){ state.peers[other].out+=value; state.peers[other].outTx++; state.edges[addr.toLowerCase()+"->"+other.toLowerCase()] ??= {value:0,count:0,native:true}; state.edges[addr.toLowerCase()+"->"+other.toLowerCase()].value += Number(fmtEth(value)); state.edges[addr.toLowerCase()+"->"+other.toLowerCase()].count++; }
            else     { state.peers[other].in +=value; state.peers[other].inTx++;  state.edges[other.toLowerCase()+"->"+addr.toLowerCase()] ??= {value:0,count:0,native:true}; state.edges[other.toLowerCase()+"->"+addr.toLowerCase()].value += Number(fmtEth(value)); state.edges[other.toLowerCase()+"->"+addr.toLowerCase()].count++; }
            state.firstSeen=Math.min(state.firstSeen,ts); state.lastSeen=Math.max(state.lastSeen,ts); state.totalNativeTxs++;
          }
        });
      });
      state.lastScannedBlock = Math.max(state.lastScannedBlock, arr[arr.length-1]);
      // progress (0–70%)
      const done = state.lastScannedBlock - (ui.genesis.checked ? 0 : startBlock) + 1;
      ui.prog.style.width = Math.min(70, (done/totalSpan)*70).toFixed(1)+'%';
      await dbPut(cacheKey,state); // persist often
      await sleep(1);
    }
  }

  // Token/NFT logs (fast, big ranges)
  const TRANSFER_TOPIC="0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
  const LOG_CHUNK=Math.max(2000, Number(ui.logChunk.value));
  for(let from=0; from<=head; from+=LOG_CHUNK){
    const to=Math.min(head, from+LOG_CHUNK-1);
    try{
      const logs = await provider.send("eth_getLogs", [{fromBlock:'0x'+from.toString(16), toBlock:'0x'+to.toString(16), topics:[TRANSFER_TOPIC]}]);
      for(const L of logs){
        const f="0x"+L.topics[1].slice(26), t="0x"+L.topics[2].slice(26);
        if(f.toLowerCase()!==addr.toLowerCase() && t.toLowerCase()!==addr.toLowerCase()) continue;
        const other = f.toLowerCase()===addr.toLowerCase() ? ethers.getAddress(t) : ethers.getAddress(f);
        const blk=await provider.getBlock(L.blockNumber); const ts=blk.timestamp;
        state.days[dayKey(ts)] ??= {in:0,out:0,ev:0}; state.days[dayKey(ts)].ev += 1;

        // aggregate edges but mark native:false
        const out = f.toLowerCase()===addr.toLowerCase();
        const key = (out? addr.toLowerCase()+"->"+other.toLowerCase() : other.toLowerCase()+"->"+addr.toLowerCase());
        state.edges[key] ??= {value:0,count:0,native:false}; state.edges[key].count++;
        state.firstSeen=Math.min(state.firstSeen,ts); state.lastSeen=Math.max(state.lastSeen,ts);
      }
    }catch(e){ console.warn("logs chunk failed",e.message); }
    // progress 70–95%
    const p = 70 + Math.min(25, ((to/head)*25));
    ui.prog.style.width = p.toFixed(1)+'%';
    await dbPut(cacheKey,state);
    await sleep(1);
  }

  // detect contracts
  await Promise.all(Object.keys(state.peers).map(async p=>{ try{ const code=await provider.getCode(p); state.peers[p].isContract = (code && code!=='0x'); }catch{} }));
  ui.prog.style.width='98%';

  // Summaries
  const peersCount=Object.keys(state.peers).length;
  ui.peers.textContent=String(peersCount);
  ui.flow.textContent=`${Number(fmtEth(state.inflow)).toFixed(5)} / ${Number(fmtEth(state.outflow)).toFixed(5)} MON`;
  ui.seen.textContent = `${new Date((state.firstSeen===Infinity?Date.now()/1000:state.firstSeen)*1000).toLocaleString()} — ${new Date(state.lastSeen*1000).toLocaleString()}`;

  const summary={
    address:addr,balance:fmtEth(await provider.getBalance(addr)),nonce,
    peers:state.peers,inflow:Number(fmtEth(state.inflow)),outflow:Number(fmtEth(state.outflow)),
    firstSeen:state.firstSeen===Infinity?(Date.now()/1000):state.firstSeen,lastSeen:state.lastSeen,
    totalNativeTxs:state.totalNativeTxs,inCount:state.inCount,outCount:state.outCount,smallTxs:state.smallTxs,
    // compute bursts
    bursts:(()=>{const bins={}; Object.values(state.edges).forEach(e=>{ /* edge-only; rough */ }); return 0;})(),
    twoWayPairs:(()=>{const keys=Object.keys(state.edges), set=new Set(); let c=0; for(const k of keys){const [a,b]=k.split("->"); if(set.has(b+"->"+a)) c++; set.add(k);} return c;})()
  };
  const sc=sybilScore(summary); ui.risk.textContent=`${sc.label} (${sc.score})`; ui.risk.className='value risk '+(sc.cls);

  // Timeline
  renderTimeline(state.days);

  // Graph (aggregated edges)
  renderGraph(addr, state);

  ui.prog.style.width='100%';

  lastReport={summary, days:state.days, edges:state.edges, peers:state.peers, generatedAt:new Date().toISOString(), chainId:10143, rpc:RPC_URL, window:{from:ui.genesis.checked?0:startBlock, to:head}};
  await dbPut(cacheKey,state); // final persist
}

/* Timeline */
function renderTimeline(days){
  const labels=Object.keys(days).sort();
  const inflows=labels.map(k=>days[k].in||0), outflows=labels.map(k=>days[k].out||0), ev=labels.map(k=>days[k].ev||0);
  if(timelineChart) timelineChart.destroy();
  timelineChart=new Chart(document.getElementById('timeline'),{type:'bar',data:{labels,datasets:[{label:'Inflow (MON)',data:inflows},{label:'Outflow (MON)',data:outflows},{label:'Token/NFT Events',data:ev}]},options:{responsive:true,scales:{x:{grid:{display:false},ticks:{color:'#9fb0ff'}},y:{grid:{color:'#1b2442'},ticks:{color:'#9fb0ff'}}},plugins:{legend:{labels:{color:'#cfe3ff'}}}}});
}

/* Graph from aggregated edges */
function renderGraph(center, state){
  const el=document.getElementById('graph'); el.innerHTML='';
  const w=el.clientWidth,h=el.clientHeight;
  const svg=d3.select(el).append('svg').attr('width',w).attr('height',h);
  const nodesMap=new Map(); nodesMap.set(center.toLowerCase(),{id:center,type:'self'});
  Object.entries(state.peers).forEach(([a,info])=> nodesMap.set(a.toLowerCase(),{id:a,type:info.isContract?'contract':'peer'}));
  const links=Object.entries(state.edges).map(([k,e])=>{const [s,t]=k.split('->'); return {source:s,target:t,value:e.value,native:e.native};});
  const nodes=[...nodesMap.values()];

  const g=svg.append('g'); svg.call(d3.zoom().scaleExtent([.3,4]).on('zoom',e=>g.attr('transform',e.transform)));
  const sim=d3.forceSimulation(nodes)
    .force('link',d3.forceLink(links).id(d=>d.id).distance(d=>100).strength(.6))
    .force('charge',d3.forceManyBody().strength(-220))
    .force('center',d3.forceCenter(w/2,h/2))
    .force('radial',d3.forceRadial(d=> d.type==='self'? 0 : 220, w/2, h/2).strength(.06));

  const edge=g.append('g').selectAll('line').data(links).enter().append('line')
    .attr('stroke', d=> d.source===center.toLowerCase() ? '#ff6b6b' : '#23d1a2')
    .attr('stroke-opacity',.45).attr('stroke-width',d=>1+Math.min(6,Math.log((d.value||1)+2)));

  const node=g.append('g').selectAll('circle').data(nodes).enter().append('circle')
    .attr('r',d=>d.type==='self'?10:6).attr('fill',d=>d.type==='self'?'#93c5fd':d.type==='contract'?'#f59e0b':'#a3b8ff')
    .attr('stroke','#2c365e').attr('stroke-width',1)
    .call(d3.drag().on('start',e=>{if(!e.active)sim.alphaTarget(.2).restart(); e.subject.fx=e.subject.x; e.subject.fy=e.subject.y;})
                    .on('drag',e=>{e.subject.fx=e.x; e.subject.fy=e.y;})
                    .on('end',e=>{if(!e.active)sim.alphaTarget(0); e.subject.fx=null; e.subject.fy=null;}));

  const tip=d3.select('body').append('div').style('position','fixed').style('pointer-events','none')
    .style('background','#0d1330cc').style('border','1px solid #27325d').style('padding','8px 10px').style('border-radius','10px')
    .style('color','#dfe7ff').style('font','12px ui-monospace').style('display','none');
  node.on('mouseover',(e,d)=>{const p=state.peers[d.id]||{}; tip.style('display','block').html(`<div class="mono">${short(d.id)}</div><div>${d.type==='self'?'Target':d.type==='contract'?'Contract':'EOA'}</div>${d.id.toLowerCase()!==center.toLowerCase()?`<div>In: ${p.in?Number(fmtEth(p.in)).toFixed(6):0} · Out: ${p.out?Number(fmtEth(p.out)).toFixed(6):0}</div>`:''}`)})
      .on('mousemove',e=>tip.style('left',(e.clientX+12)+'px').style('top',(e.clientY+12)+'px'))
      .on('mouseout',()=>tip.style('display','none'));
  sim.on('tick',()=>{edge.attr('x1',d=>d.source.x).attr('y1',d=>d.source.y).attr('x2',d=>d.target.x).attr('y2',d=>d.target.y); node.attr('cx',d=>d.x).attr('cy',d=>d.y);});
}

/* Export */
exportBtn.onclick=()=>{
  if(!lastReport){alert('Run a scan first.');return;}
  const blob=new Blob([JSON.stringify(lastReport,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`sybil-report-${lastReport.summary.address}.json`; a.click(); URL.revokeObjectURL(url);
};

/* Run */
scanBtn.onclick=async()=>{
  try{ await scan(addr.value.trim()); }catch(e){ console.error(e); alert('Scan failed: '+(e.message||e)); ui.prog.style.width='0%'; }
};
</script>
</body>
</html>
